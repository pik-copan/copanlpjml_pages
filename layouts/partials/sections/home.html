{{ $author:= site.Data.author }}
{{ if (index site.Data site.Language.Lang).author }}
  {{ $author = (index site.Data site.Language.Lang).author }}
{{ end }}

{{ $name:="Jane Doe" }}
{{ if $author.nickname }}
  {{ $name = $author.nickname }}
{{ else if $author.name }}
  {{ $name = $author.name }}
{{ end }}

{{ $sections:= site.Data.sections }}
{{ if (index site.Data site.Language.Lang).sections }}
  {{ $sections = (index site.Data site.Language.Lang).sections }}
{{ end }}

{{ $backgroundImage:= "/images/default-background.jpg" }}
{{ if site.Params.background }}
  {{ $backgroundImage = site.Params.background }}
{{ end }}


{{ $authorImage:= "/images/default-avatar.png" }}
{{ if $author.image }}
  {{ $authorImage = $author.image }}
{{ end }}
{{ $authorImage := resources.Get $authorImage }}

{{/* apply image processing. don't use "Fit" in svg or gif because its not supported */}}
{{ if and $authorImage (and (ne $authorImage.MediaType.SubType "svg") ( ne $authorImage.MediaType.SubType "gif")) }}
  {{ $authorImage = $authorImage.Fit "148x148" }}
{{ end }}
{{/* get file that matches the filename as specified as src="" in shortcode */}}
{{ $src := resources.Get $backgroundImage }}

{{/* set image sizes, these are hardcoded for now, x dictates that images are resized to this width */}}

{{ $tinyw := default "500x" }}
{{ $smallw := default "800x" }}
{{ $mediumw := default "1200x" }}
{{ $largew := default "1500x" }}

{{/* resize the src image to the given sizes */}}

{{ $tiny := $src.Resize $tinyw }}
{{ $small := $src.Resize $smallw }}
{{ $medium := $src.Resize $mediumw }}
{{ $large := $src.Resize $largew }}

{{/* only use images smaller than or equal to the src (original) image size, as Hugo will upscale small images */}}
{{/* set the sizes attribute to (min-width: 35em) 1200px, 100vw unless overridden in shortcode */}}

{{ if lt $src.Width "500" }}
  {{ $tiny := $src}}
  {{ $small := $src}}
  {{ $medium := $src}}
  {{ $large := $src}}
{{ end }}

{{ if lt $src.Width "800" }}
  {{ $small := $src}}
  {{ $medium := $src}}
  {{ $large := $src}}
{{ end }}

{{ if lt $src.Width "1200" }}
  {{ $medium := $src}}
  {{ $large := $src}}
{{ end }}

{{ if lt $src.Width "1500" }}
  {{ $large := $src}}
{{ end }}

<div class="container-fluid home" id="home">
  <style>
    /* 0 to 299 */
    #homePageBackgroundImageDivStyled {
      background-image: url('{{ $tiny.RelPermalink }}');
    }
    /* 300 to X */
    @media (min-width: 500px) and (max-width: 800px) { /* or 301 if you want really the same as previously.  */
      #homePageBackgroundImageDivStyled {   
          background-image: url('{{ $small.RelPermalink }}');
        }
    }
    @media (min-width: 801px) and (max-width: 1200px) { /* or 301 if you want really the same as previously.  */
      #homePageBackgroundImageDivStyled {   
          background-image: url('{{ $medium.RelPermalink }}');
        }
    }
    @media (min-width: 1201px) and (max-width: 1500px) { /* or 301 if you want really the same as previously.  */
      #homePageBackgroundImageDivStyled {   
          background-image: url('{{ $large.RelPermalink }}');
        }
    }
    @media (min-width: 1501px) { /* or 301 if you want really the same as previously.  */
      #homePageBackgroundImageDivStyled {   
          background-image: url('{{ $src.RelPermalink }}');
        }
    }

    .home {
      height: 100vh;
      width: 100%;
      position: relative;
      overflow: hidden;
    }

    @media (max-width: 768px) {
      .home {
        height: 80vh;
      }
    }

    .animated-shards-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #networkCanvas {
      width: 100%;
      height: 100%;
    }
    .container.content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      text-align: center;
      padding: 20px;
    }
    .content img {
      width: 45%;
      max-width: 600px;
      height: auto;
      margin-bottom: 2rem;
      background: transparent !important;
    }

    @media (max-width: 768px) {
      .content img {
        width: 60%;
        max-width: 300px;
        margin-bottom: 1rem;
      }
    }

    .typing-carousel {
      font-size: 1.2rem;
      margin: 1rem 0;
      min-height: 2em;
    }
    #typing-carousel-data {
      display: none;
    }
    .ityped-cursor {
      animation: blink 0.8s infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    .arrow.bounce {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      animation: bounce 2s infinite;
    }
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
      40% { transform: translateX(-50%) translateY(-20px); }
      60% { transform: translateX(-50%) translateY(-10px); }
    }

    /* Background shapes */
    .shard {
      position: absolute;
      width: 15vw;
      height: 15vw;
      filter: blur(15px);
      opacity: 0.7;
      mix-blend-mode: multiply;
    }

    @media (max-width: 768px) {
      .typing-carousel {
        font-size: 1rem;
        margin: 0.5rem 0;
      }
      .arrow.bounce {
        bottom: 1rem;
        font-size: 1.5rem;
      }
    }
    </style>
    <span class="on-the-fly-behavior"></span>
    <div class="animated-shards-background container-fluid">
      <div class="shard shard1"></div>
      <div class="shard shard2"></div>
      <div class="shard shard3"></div>
      <div class="shard shard4"></div>
      <div class="shard shard5"></div>
      <div class="shard shard6"></div>
      <div class="shard shard7"></div>
      <div class="shard shard8"></div>
      <div class="shard shard9"></div>
      <div class="shard shard10"></div>
      <div class="shard shard11"></div>
      <div class="shard shard12"></div>
      <div class="shard shard13"></div>
      <div class="shard shard14"></div>
      <div class="shard shard15"></div>
      <canvas id="networkCanvas"></canvas>
    </div>
    
    <div class="container content text-center">
    <img src="{{ $authorImage.RelPermalink }}"
      class="mx-auto d-block img-fluid"
      alt="Author Image"
    />
    <div class="typing-carousel" style="color: black;">
      <span id="ityped" class="ityped"></span>
      <span class="ityped-cursor"></span>
    </div>
    <ul id="typing-carousel-data">
      {{ if $author.summary }}
        {{ range $author.summary }}
          <li>{{ . }}</li>
        {{ end}}
      {{ end }}
    </ul>
    {{ if $sections }}
      {{ range first 1 (where (sort $sections "section.weight") ".section.enable" true) }}
        {{ $sectionID := replace (lower .section.name) " " "-"  }}
        {{ if .section.id }}
          {{ $sectionID = .section.id }}
        {{ end }}
        <a href="#{{ $sectionID }}" aria-label="{{ i18n "read" }} {{ i18n "more" }} - {{ $name }}"><i class="arrow bounce fa fa-chevron-down"></i></a>
      {{ end }}
    {{ end }}
  </div>
</div>

<script>
  const canvas = document.getElementById("networkCanvas");
  const ctx = canvas.getContext("2d");
  const shards = Array.from(document.querySelectorAll(".shard"));

  function resizeCanvas() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
  }

  window.addEventListener("resize", resizeCanvas);
  window.addEventListener("orientationchange", resizeCanvas);
  window.addEventListener("load", resizeCanvas);
  resizeCanvas();

  function getShardCenters() {
    const parentRect = canvas.getBoundingClientRect();
    return shards.map(el => {
      const rect = el.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2 - parentRect.left,
        y: rect.top + rect.height / 2 - parentRect.top
      };
    });
  }

  let connections = new Set();

  function generateRandomConnections(centers, numConnections) {
    // Increase connections for both mobile and desktop
    const isMobile = window.innerWidth <= 768;
    numConnections = isMobile ? 200 : 300;

    const newConnections = [];
    const indices = centers.map((_, i) => i);
    for (let i = 0; i < numConnections; i++) {
      const a = indices[Math.floor(Math.random() * indices.length)];
      let b = a;
      while (b === a) {
        b = indices[Math.floor(Math.random() * indices.length)];
      }
      const pair = [a, b].sort();
      const pairKey = pair.join(',');
      if (!connections.has(pairKey)) {
        connections.add(pairKey);
        newConnections.push(pair);
      }
    }
    connections = new Set([...connections, ...newConnections.map(pair => pair.join(','))]);
  }

  setInterval(() => {
    const centers = getShardCenters();
    generateRandomConnections(centers);
  }, 5000);

  generateRandomConnections(getShardCenters());

  function drawNetwork() {
    const centers = getShardCenters();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const isMobile = window.innerWidth <= 768;
    const maxDist = Math.min(canvas.width, canvas.height) * (isMobile ? 0.4 : 0.45);
    const maxDist2 = maxDist * maxDist;

    for (const connection of connections) {
      const [i, j] = connection.split(',').map(Number);
      const dx = centers[i].x - centers[j].x;
      const dy = centers[i].y - centers[j].y;
      const dist2 = dx * dx + dy * dy;

      if (dist2 < maxDist2) {
        const alpha = 1 - dist2 / maxDist2;
        ctx.strokeStyle = `rgba(30, 30, 30, ${alpha.toFixed(2)})`;
        ctx.beginPath();
        ctx.moveTo(centers[i].x, centers[i].y);
        ctx.lineTo(centers[j].x, centers[j].y);
        ctx.stroke();
      }
    }

    const dotSize = 2;
    for (let i = 0; i < centers.length; i++) {
      ctx.beginPath();
      ctx.arc(centers[i].x, centers[i].y, dotSize, 0, 2 * Math.PI);
      ctx.fillStyle = "#111";
      ctx.fill();
    }

    requestAnimationFrame(drawNetwork);
  }

  drawNetwork();
</script>